# WAI-UI 자동 푸시 & 로컬 스냅샷 시스템 정리

이 문서는 **C:\wai-ui\frontend** 환경에서 사용하는 두 가지 자동화 도구의 동작 원리를 정리한 것이다.

- `wai_magic.py`  
  → **자동 파일 저장 + git add/commit/push**  
- `tools/wai_local_snapshot.py`  
  → **로컬 스냅샷 저장 + 복구 + 복구 후 전체 커밋/푸시**

새 채팅 시작 시 이 문서를 그대로 전달하면, 챗봇이 현재 개발 환경을 이해하고 그에 맞는 형식으로 코드를 내보낼 수 있다.

---

## 0. 기본 전제

- 프로젝트 루트: `C:\wai-ui\frontend`
- Git 리포지토리 루트: 동일 (`C:\wai-ui\frontend`)
- Python 및 `pyperclip` 설치
- 사용 도구:
  - `wai_magic.py` (루트)
  - `tools/wai_local_snapshot.py` (하위 폴더)

일반적인 실행 방식:

- CMD 1

    cd C:\wai-ui\frontend
    py wai_magic.py

- CMD 2

    cd C:\wai-ui\frontend
    py tools\wai_local_snapshot.py

이 두 창을 켜 둔 상태에서, 챗봇이 제공하는 블록을 복사/붙여넣기 하며 작업한다.

---

## 1. 자동 푸시 시스템: `wai_magic.py`

### 1-1. 역할 개요

`wai_magic.py`는 **클립보드 감시기**로, 다음 형식의 블록을 감지해 자동으로 파일 저장과 Git 작업을 수행한다.

- 클립보드에 포함된 패턴:

    (해당 파일의 전체 내용)

이 블록을 감지하면:

1. `C:\wai-ui\frontend\상대/경로.ext` 위치에 **파일 전체를 덮어쓰기**로 저장.
2. Git 리포지토리일 경우:
   - 각 파일에 대해 `git add 상대/경로.ext`.
3. 한 번의 클립보드 텍스트에 포함된 **모든 `WAI:UPDATE` 블록을 처리한 뒤**:
   - 한 번의 `git commit` 과 `git push` 를 수행.

### 1-2. PROMPT 번호와 진행률 표기

한 번의 클립보드 텍스트(=한 번의 챗봇 응답)를 하나의 **PROMPT 단위**로 본다.

- 클립보드 전체 텍스트에 대해 `SHA1` 해시를 계산 (`text_hash`).
- `text_hash`를 기준으로 **PROMPT ID (정수 N)** 를 배정/조회한다.
  - 같은 텍스트라면 항상 같은 PROMPT N을 사용.
  - 이 정보는 `_snapshots/prompt_state.json`에 저장되며,
    `wai_local_snapshot.py`와 **공유**된다.

클립보드 안에 `WAI:UPDATE` 블록이 3개 있다면, 처리 로그는 예를 들어 다음과 같이 찍힌다.

- 파일별 처리 로그

    [PROMPT 18 1/3] index.html 저장 + git add
    [PROMPT 18 2/3] js/core/app-root.js 저장 + git add
    [PROMPT 18 3/3] tools/wai_local_snapshot.py 저장 + git add

여기서:

- `PROMPT 18` : 이번 텍스트(프롬프트 단위 작업)의 ID.
- `1/3, 2/3, 3/3` :  
  이번 텍스트 안에 있는 **전체 수정 대상 파일(3개) 중 몇 번째 파일인지**를 나타냄.  
  (파일 한 개의 “저장/커밋/푸시 단계”가 아니라, **파일 순번/전체 개수** 의미)

모든 파일을 저장/`git add` 한 뒤:

- 변경 사항이 있으면:

    [PROMPT 18] git commit 완료: [WAI] Prompt 18: 3 file(s) updated
    [PROMPT 18] git push 완료

→ **한 번의 프롬프트**가:

- 여러 파일 수정 → 저장 + git add
- 한 번의 commit
- 한 번의 push

로 자동 정리된다.

---

## 2. 로컬 스냅샷 시스템: `tools/wai_local_snapshot.py`

### 2-1. 스냅샷의 의미와 범위

`wai_local_snapshot.py`는 **로컬 전용 “세이브 포인트” 시스템**이다.

- 스냅샷 1개 =  
  `C:\wai-ui\frontend` 전체 상태를 `_snapshots/스냅샷폴더` 아래에 복사해 둔 것.
- 포함 범위:
  - `REPO_ROOT = C:\wai-ui\frontend` 기준으로 `os.walk`.
  - 다음 디렉터리는 **제외**:
    - `.git`, `_snapshots`, `venv`, `env`, `.venv`, `node_modules`, `.idea`, `.vscode`, `__pycache__`
  - `.pyc`, `.pyo` 등 불필요한 파일은 스킵.
- 구조 예:

    _snapshots/
      20251212_091113_P18_SNAP/
        index.html
        js/core/app-root.js
        ...
        manifest.json

`manifest.json`에는 다음 정보가 담긴다.

- `description` : 사용자가 입력한 설명 문자열.
- `prompt_index` : PROMPT 번호 (정수 N).
- `created_at` : 생성 시각.
- `files` : 포함된 파일 상대경로 리스트.

항상 **최신 3개 스냅샷만 유지**하고, 새 스냅샷을 만들 때 가장 오래된 것부터 자동 삭제한다.

---

### 2-2. 클립보드 워처(자동 스냅샷)

인자 없이 실행:

    cd C:\wai-ui\frontend
    py tools\wai_local_snapshot.py

- 실행되면:

    === WAI Local Snapshot Watcher ===
    클립보드에 다음 형식이 포함되면 자동으로 스냅샷을 저장합니다:
      ### [WAI:LOCAL_SNAPSHOT:설명]
    중지하려면 Ctrl + C 를 누르세요.

- 시작 시:
  - 현재 클립보드 내용을 한 번 읽어서 `last_text`로만 저장하고, **스냅샷은 찍지 않는다.**
  - 즉, 워처 실행 전에 클립보드에 남아 있던 옛 텍스트는 무시.

- 이후 루프에서:
  1. 주기적으로 `pyperclip.paste()`로 클립보드 내용 확인.
  2. 내용이 `last_text`와 달라졌으면:
     - 텍스트 안에서 다음 패턴을 검색:

           ### [WAI:LOCAL_SNAPSHOT:설명문자열]

     - 발견되면:
       - 전체 텍스트에 대해 `SHA1` 해시(`text_hash`) 계산.
       - 이 `text_hash`로 PROMPT ID N을 배정/조회  
         (`prompt_state.json` 공유 → `wai_magic.py`와 동일 번호 사용).
       - `save_snapshot("설명문자열", N)` 호출 → 스냅샷 생성.
       - 로그 예:

             [PROMPT 18 | 2025-12-12 09:11:13]
              ✨ [로컬 스냅샷 저장] 20251212_091113_P18_SNAP
                 경로   : C:\wai-ui\frontend\_snapshots\20251212_091113_P18_SNAP
                 파일수 : 21
                 복구   : py tools\wai_local_snapshot.py restore 20251212_091113_P18_SNAP
                 설명   : 설명문자열

**중요한 점:**  
- `wai_magic.py`와 `wai_local_snapshot.py`가 둘 다 **같은 클립보드 텍스트**를 보면,
- 똑같은 `text_hash`로 PROMPT 번호를 배정하므로,
- `PROMPT 18` 기준으로:
  - 스냅샷 로그
  - 파일 저장/커밋/푸시 로그  
  가 한 묶음으로 정렬된다.

---

### 2-3. 수동 스냅샷 (CLI save)

워처와 상관 없이 **직접 스냅샷을 찍고 싶을 때**:

    cd C:\wai-ui\frontend
    py tools\wai_local_snapshot.py save "P18: 큰 리팩토링 전"

- `prompt_state.json` 의 `last_id + 1` 로 새 PROMPT 번호를 할당.
- `last_hash` 는 빈 문자열로 초기화.
- 그 번호를 사용해 frontend 전체 스냅샷 생성.
- 클립보드/프롬프트와 무관한, **수동 세이브 포인트**로 쓸 수 있다.

---

### 2-4. 스냅샷 목록 (list)

현재 존재하는 스냅샷 목록을 보고 싶을 때:

    cd C:\wai-ui\frontend
    py tools\wai_local_snapshot.py list

- `_snapshots/` 디렉터리 아래 폴더들을 **오래된 것부터** 나열.
- 각 항목에 대해:

    - 폴더 이름
    - PROMPT 번호
    - 생성 시각
    - 설명(description)

을 출력한다.

---

### 2-5. 복구 + 전체 Git 커밋/푸시 (restore)

특정 스냅샷으로 **workspace 전체를 롤백**하고,  
그 상태를 GitHub에 하나의 버전으로 올리고 싶을 때:

    cd C:\wai-ui\frontend
    py tools\wai_local_snapshot.py restore 20251212_091113_P18_SNAP

동작 순서:

1. `_snapshots/해당폴더/manifest.json` 읽기
   - `files` 목록을 기준으로, 각 파일을 `C:\wai-ui\frontend`로 덮어쓰기.
   - `_snapshots` 자체는 스냅샷 대상/복구 대상에서 제외되므로,  
     **스냅샷 히스토리 자체는 덮어쓰지 않는다.**
2. 복구 완료 메시지 출력:

       스냅샷 복구가 완료되었습니다.

3. 현재 디렉터리가 Git 리포지토리인 경우,  
   **복구된 상태를 하나의 버전으로 커밋 + 푸시**:

   - 변경 여부 확인:

         git status --porcelain

   - 변경이 있다면:

     1. `git add -A`
     2. 커밋 메시지 생성:
        - manifest에 `prompt_index`가 있으면:

              [RESTORE SNAPSHOT P18] Restore from local snapshot 20251212_091113_P18_SNAP

        - 없으면:

              [RESTORE SNAPSHOT] Restore from local snapshot 20251212_091113_P18_SNAP

     3. `git commit -m "<위 메시지>"`

     4. `git push`

   - 로그 예:

         [RESTORE] git add -A 실행 중...
         [RESTORE] git commit 완료: [RESTORE SNAPSHOT P18] Restore from local snapshot 20251212_091113_P18_SNAP
         [RESTORE] git push 실행 중...
         [RESTORE] git push 완료

이렇게 하면:

- 로컬 작업 폴더는 **스냅샷 시점 그대로**로 돌아가고,
- 그 상태 전체가 GitHub에도 **하나의 커밋**으로 반영된다.
- 이후부터는 다시 `wai_magic.py` 를 통해 프롬프트 단위로 commit/push 를 쌓아가면 된다.

---

## 3. PROMPT 번호 공유 규칙

두 스크립트는 `_snapshots/prompt_state.json` 을 통해 **PROMPT ID를 공유**한다.

- 구조 (예시):

    {
      "last_id": 18,
      "last_hash": "abcd1234..."  # 최근에 처리한 클립보드 전체 텍스트의 SHA1
    }

- `wai_magic.py` 와 `wai_local_snapshot.py`는:
  - 동일한 클립보드 텍스트(`text_hash`)에 대해서:
    - 같은 PROMPT ID (예: 18)을 사용.
  - 서로 다른 텍스트라면:
    - `last_id + 1` 하여 새 PROMPT ID를 발급.

그래서, 한 프롬프트 안에서:

- 스냅샷:

    [PROMPT 18 | ...] ✨ [로컬 스냅샷 저장] ...

- 파일 저장/커밋/푸시:

    [PROMPT 18 1/3] ...
    [PROMPT 18 2/3] ...
    [PROMPT 18 3/3] ...
    [PROMPT 18] git commit 완료 ...
    [PROMPT 18] git push 완료

가 모두 같은 `PROMPT 18` 기준으로 묶인다.

CLI `save` 호출은:

- 텍스트 해시 없이 `last_id + 1`만 증가시키므로,
- 클립보드 프롬프트와는 독립적인 번호를 가진 스냅샷이 된다.

---

## 4. 챗봇이 지켜야 할 출력 규칙 (이 시스템과 관련된 부분만)

1. **파일 수정 시**  
   각 파일은 **반드시 전체 내용을 한 블록으로** 제공해야 한다.

    - 형식:

          ### [WAI:UPDATE:상대/경로.ext]
          (해당 파일의 전체 내용)

    - 한 파일당 `WAI:UPDATE` 블록 1개.
    - diff/patch/부분수정은 사용하지 않는다.

2. **프롬프트(한 번의 답변) 끝에는 스냅샷 트리거 블록을 하나 넣는다.**

    - 형식:

          ### [WAI:LOCAL_SNAPSHOT:간단한-설명문자열]

    - 예:

          ### [WAI:LOCAL_SNAPSHOT:P18_프리뷰-리팩토링-후]

    - 사용자는 이 블록까지 포함된 전체 답변을 한 번에 복사하면:
      - `wai_magic.py`: 모든 `WAI:UPDATE` 파일 저장 + git add + commit + push
      - `wai_local_snapshot.py`: 동일 PROMPT ID로 로컬 스냅샷 생성

3. **챗봇은 스크립트를 실행하거나 복구 명령을 직접 수행하지 않는다.**

    - 실행/복구/명령어 입력은 **사용자 측 CLI 작업**이다.
    - 챗봇은 오직:
      - `### [WAI:UPDATE:...]`
      - `### [WAI:LOCAL_SNAPSHOT:...]`
      를 정확한 형식으로 출력하는 것만 책임진다.

이 규칙을 지키면:

- 한 프롬프트마다:
  - 자동 파일 저장 + 자동 커밋/푸시 (`wai_magic.py`)
  - 동일 PROMPT 기준 로컬 전체 스냅샷 (`wai_local_snapshot.py`)
- 문제가 생기면:
  - 원하는 스냅샷으로 복구 + 그 상태를 하나의 Git 버전으로 고정

이라는 안정적인 작업 흐름을 유지할 수 있다.
